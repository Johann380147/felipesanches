//PDB parsing:
var molecule={"atoms": [], "bonds": []};
var molecules_pdb = [
"HEADER    Caffeine: Trimethylxanthine; a cardiac stimulant and diuretic\n\
AUTHOR    Created by Dave Woodcock at Okanagan University College\n\
AUTHOR    email:woodcock@okanagan.bc.ca\n\
AUTHOR    Date revised: Fri Sep 29 14:53:27 2000  GENERATED BY BABEL 1.6 \n\
HETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \n\
HETATM    2  C           1       1.392   0.000   0.000  1.00  0.00 \n\
HETATM    3  N           1       2.076   1.164   0.000  1.00  0.00 \n\
HETATM    4  C           1       1.373   2.321  -0.003  1.00  0.00 \n\
HETATM    5  O           1       1.978   3.365  -0.017  1.00  0.00 \n\
HETATM    6  N           1       0.017   2.344   0.003  1.00  0.00 \n\
HETATM    7  C           1      -0.710   1.202   0.002  1.00  0.00 \n\
HETATM    8  O           1      -1.915   1.218  -0.006  1.00  0.00 \n\
HETATM    9  N           1      -0.404  -1.287  -0.019  1.00  0.00 \n\
HETATM   10  N           1       1.830  -1.279  -0.020  1.00  0.00 \n\
HETATM   11  C           1       0.715  -2.048  -0.031  1.00  0.00 \n\
HETATM   12  C           1      -1.795  -1.761  -0.044  1.00  0.00 \n\
HETATM   13  C           1       3.546   1.178  -0.016  1.00  0.00 \n\
HETATM   14  C           1      -0.690   3.634  -0.013  1.00  0.00 \n\
HETATM   15  H           1       0.720  -3.138  -0.055  1.00  0.00 \n\
HETATM   16  H           1      -1.813  -2.850  -0.090  1.00  0.00 \n\
HETATM   17  H           1      -2.307  -1.428   0.860  1.00  0.00 \n\
HETATM   18  H           1      -2.302  -1.352  -0.918  1.00  0.00 \n\
HETATM   19  H           1       3.894   1.455  -1.011  1.00  0.00 \n\
HETATM   20  H           1       3.929   0.190   0.239  1.00  0.00 \n\
HETATM   21  H           1       3.911   1.904   0.710  1.00  0.00 \n\
HETATM   22  H           1      -1.557   3.583   0.645  1.00  0.00 \n\
HETATM   23  H           1      -0.027   4.428   0.329  1.00  0.00 \n\
HETATM   24  H           1      -1.020   3.851  -1.029  1.00  0.00 \n\
CONECT    1    2    2    7    9\n\
CONECT    2    1    1    3   10\n\
CONECT    3    2    4   13\n\
CONECT    4    3    5    5    6\n\
CONECT    5    4    4\n\
CONECT    6    4    7   14\n\
CONECT    7    1    6    8    8\n\
CONECT    8    7    7\n\
CONECT    9    1   11   12\n\
CONECT   10    2   11   11\n\
CONECT   11    9   10   10   15\n\
CONECT   12    9   16   17   18\n\
CONECT   13    3   19   20   21\n\
CONECT   14    6   22   23   24\n\
CONECT   15   11\n\
CONECT   16   12\n\
CONECT   17   12\n\
CONECT   18   12\n\
CONECT   19   13\n\
CONECT   20   13\n\
CONECT   21   13\n\
CONECT   22   14\n\
CONECT   23   14\n\
CONECT   24   14\n\
MASTER        0    0    0    0    0    0    0    0   24    0   24    0\n\
END"]

function get_atom_data (label)
  {
    return "";

//TODO:
/*
  int i;
  const atom_data *d = 0;
  char *n = strdup (atom_name);
  char *n2 = n;
  int L;

  while (!isalpha(*n)) n++;
  L = strlen(n);
  while (L > 0 && !isalpha(n[L-1]))
    n[--L] = 0;

  for (i = 0; i < countof(all_atom_data); i++)
    {
      d = &all_atom_data[i];
      if (!strcasecmp (n, all_atom_data[i].name))
        break;
    }

  free (n2);
  return d;
*/
  }

function push_atom (m, id, label, x, y, z)
  {
    m.atoms.push({"id": id, "label": label, "x": x, "y": y, "z": z, "data": get_atom_data (label)});
  }

function push_bond (m, from, to)
  {
    var i;

    for (i = 0; i < m.bonds.length; i++)
      if ((m.bonds[i].from == from && m.bonds[i].to == to) ||
          (m.bonds[i].to == from && m.bonds[i].from == to))
        {
          m.bonds[i].strength++;
          return;
        }

    m.bonds.push({"from": from, "to": to, "strength": 1});
  }

function parse_pdb_data (molecule, data)
  {
    var lines = data.split("\n");
    for (var l in lines)
      {
        line = "";
        for (c in lines[l])
          {
            if (lines[l][c]==" "){
              if (!skip)
                line += " ";
              skip=true;
            } else {
              line += lines[l][c];
              skip=false;
            }
          }

        var fields = line.split(" ");
        var keyword = fields[0];
        fields[0]="";

        if ((!molecule.label) && ((keyword == "HEADER") || (keyword == "COMPND")))
          {
            molecule.label = fields.join(" ");
          }
        else if (keyword == "ATOM")
        {
          //TODO
          id = 42;
          x=1;y=2;z=3;
          name="nome";
          push_atom (molecule, id, name, x, y, z);
        }
      else if (keyword == "HETATM")
        {
        //HETATM    1  C           1       0.000   0.000   0.000  1.00  0.00 \n
          var id = fields[1];
          var label=fields[2];
          var x=fields[4];
          var y=fields[5];
          var z=fields[6];
          push_atom (molecule, id, label, x, y, z);
        }
      else if (keyword == "CONECT")
        {
          var i;
          for (i = 1; i < fields.length-1; i++)
            {
              push_bond (molecule, fields[0], fields[i]);
            }
        }
      else
        {
        }
    }
  }


/* thanks to Rene Uittenbogaard <ruittenb@wish.nl> */
function special_case_formula (f)
  {
    if (f=="H[2]Be")    return "BeH[2]";
    if (f=="H[3]B")     return "BH[3]";
    if (f=="H[3]N")     return "NH[3]";
    if (f=="CHN")       return "HCN";
    if (f=="CKN")       return "KCN";
    if (f=="H[4]N[2]")  return "N[2]H[4]";
    if (f=="Cl[3]P")    return "PCl[3]";
    if (f=="Cl[5]P")    return "PCl[5]";
    return f;
  }

function serialize_element(counts, elem)
  {
    if (!counts[elem]) return "";
    res = elem;
    if (counts[elem] > 1)
      res += "["+ counts[elem] +"]";  /* use [] to get subscripts */
    return res;
  }

function generate_molecule_formula (molecule)
  {
    counts = {}
    for (var i in molecule.atoms)
      {
        var atom = molecule.atoms[i];

        if (counts[atom.label])
          counts[atom.label]++;
        else
          counts[atom.label] = 1;
      }

    var string = "";
    string += serialize_element(counts, "C"); counts["C"]=null;
    string += serialize_element(counts, "H"); counts["H"]=null;
    for (i in counts) //todo: sort alphabetically
      {
        string += serialize_element(counts, counts[i]);
      }
    string = special_case_formula (string);
    molecule.label += "\n" + string;
    return string;
  }


//WebGL:

//Globals:
var gl;
var vbuf = {}; //dict that holds vertex buffer and numitems

var vertexPositionAttribute;
var perspectiveMatrix;
var modelViewMatrix;

var do_labels = true;
var do_atoms = true;
var do_bonds = true;
var do_shells = true;
var wireframe = false;

/* saved to reset */
var orig_do_labels = do_labels;
var orig_do_atoms = do_atoms;
var orig_do_bonds = do_bonds;
var orig_do_shells = do_shells;
var orig_wireframe = wireframe;

var mvMatrix;
var mvMatrixStack = [];

function mvPushMatrix(m) {
  if (m) {
    mvMatrixStack.push(m.dup());
    mvMatrix = m.dup();
  } else {
    mvMatrixStack.push(mvMatrix.dup());
  }
}

function mvPopMatrix() {
  if (mvMatrixStack.length == 0) {
    throw "Invalid popMatrix!";
  }
  mvMatrix = mvMatrixStack.pop();
  return mvMatrix;
}

function loadIdentity() {
  mvMatrix = Matrix.I(4);
}


function multMatrix(m) {
  mvMatrix = mvMatrix.x(m);
}

function mvTranslate(v) {
  var m = Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4();
  multMatrix(m);
}

function mvRotate(ang, v) {
  var arad = ang * Math.PI / 180.0;
  var m = Matrix.Rotation(arad, $V([v[0], v[1], v[2]])).ensure4x4();
  multMatrix(m);
}

var pMatrix;
function perspective(fovy, aspect, znear, zfar) {
  pMatrix = makePerspective(fovy, aspect, znear, zfar);
}

function setMatrixUniforms(){
  gl.uniformMatrix4fv(gl.getUniformLocation(gl.program, "uPMatrix"), false, new Float32Array(pMatrix.flatten()));
  gl.uniformMatrix4fv(gl.getUniformLocation(gl.program, "uMVMatrix"), false, new Float32Array(mvMatrix.flatten()));
}

//TODO: use WebGLU instead perhaps?
function unit_sphere (vertexData, stacks, slices, wire_p)
  {
    var M_PI = 3.1415;
    var M_PI_2 = M_PI*M_PI;

    var polys = 0;
    var i,j;
    var theta1, theta2, theta3;
    var e = {"x":0, "y":0, "z":0}, p = {"x":0, "y":0, "z":0};
    var la = {"x":0, "y":0, "z":0}, lb = {"x":0, "y":0, "z":0};
    var c = {"x":0, "y":0, "z":0};  // center
    var r = 1.0;     // radius
    var stacks2 = stacks * 2;

    if (r < 0)
      r = -r;
    if (slices < 0)
      slices = -slices;

  /*
    if (slices < 4 || stacks < 2 || r <= 0)
      {
        glBegin (GL_POINTS);
        glVertex3f (c.x, c.y, c.z);
        glEnd();
        return 1;
      }
  */
    vertexData.push_point = function (point)
      {
        this.push(point.x);
        this.push(point.y);
        this.push(point.z);
      }

    //glFrontFace(GL_CW);

    for (j = 0; j < stacks; j++)
      {
        theta1 = j       * (M_PI+M_PI) / stacks2 - M_PI_2;
        theta2 = (j + 1) * (M_PI+M_PI) / stacks2 - M_PI_2;

  //      glBegin (wire_p ? GL_LINE_LOOP : GL_TRIANGLE_STRIP);
        for (i = 0; i <= slices; i++)
          {
            theta3 = i * (M_PI+M_PI) / slices;
            if (wire_p && i != 0)
              {
                vertexData.push_point(lb);
                vertexData.push_point(la);
  //              glVertex3f (lb.x, lb.y, lb.z);
  //              glVertex3f (la.x, la.y, la.z);
              }

            e.x = Math.cos (theta2) * Math.cos(theta3);
            e.y = Math.sin (theta2);
            e.z = Math.cos (theta2) * Math.sin(theta3);
            p.x = c.x + r * e.x;
            p.y = c.y + r * e.y;
            p.z = c.z + r * e.z;

  //          glNormal3f (e.x, e.y, e.z);
  //          glTexCoord2f (i       / (double)slices,
  //                        2*(j+1) / (double)stacks2);

            vertexData.push_point(p);
  //          glVertex3f (p.x, p.y, p.z);

            if (wire_p) la = p;

            e.x = Math.cos(theta1) * Math.cos(theta3);
            e.y = Math.sin(theta1);
            e.z = Math.cos(theta1) * Math.sin(theta3);
            p.x = c.x + r * e.x;
            p.y = c.y + r * e.y;
            p.z = c.z + r * e.z;

  //          glNormal3f (e.x, e.y, e.z);
  //          glTexCoord2f (i   / (double)slices,
  //                        2*j / (double)stacks2);

            vertexData.push_point(p);
  //          glVertex3f (p.x, p.y, p.z);

            if (wire_p) lb = p;
            polys++;
          }
  //      glEnd();
      }
    return polys;
  }


SPHERE_SLICES = 24  /* how densely to render spheres */
SPHERE_STACKS = 12

//controi nossa molécula e retorna uma lista de coordenadas de vertices
function build_molecule (m)
  { //TODO: wireframe
    
    var vertexData = []
    m.count_verts = unit_sphere (vertexData, SPHERE_STACKS, SPHERE_SLICES, false);
    return vertexData;
  }

function generate_molecule_vertex_buffers(m)
  {
    m.polygon_count = 0;

		vertexBuffer = gl.createBuffer();
		//    Bind the buffer object to the ARRAY_BUFFER target.
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
		//    Specify the vertex positions (x, y, z)

    do_labels = orig_do_labels;
    do_atoms  = orig_do_atoms;
    do_bonds  = orig_do_bonds;
    do_shells = orig_do_shells;
    wireframe = orig_wireframe;

//  if (m.molecule_size > m.no_label_threshold)
//    do_labels = 0;
//  if (mc->molecule_size > mc->wireframe_threshold)
//    MI_IS_WIREFRAME(mi) = 1;

//  if (wireframe)
    if (false)
      do_bonds = 1, do_shells = 0;

    if (!do_bonds)
      do_shells = 0;

    if (! (do_bonds || do_atoms || do_labels))
      {
        /* Make sure *something* shows up! */
        wireframe = 1;
        do_bonds = 1;
      }

    var vertices = build_molecule (m, false);

    vertices = [
        // Front face
         0.0,  1.0,  0.0,
        -1.0, -1.0,  1.0,
         1.0, -1.0,  1.0,
        // Right face
         0.0,  1.0,  0.0,
         1.0, -1.0,  1.0,
         1.0, -1.0, -1.0,
        // Back face
         0.0,  1.0,  0.0,
         1.0, -1.0, -1.0,
        -1.0, -1.0, -1.0,
        // Left face
         0.0,  1.0,  0.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0,  1.0
    ];


    vbuf.numItems = vertices.length/3;
    vbuf.itemSize = 3;
    vbuf.buffer = vertexBuffer;

		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    if (do_shells)
      {
//        glNewList (m.shell_dlist, GL_COMPILE);
//        ensure_bounding_box_visible (mi);

        do_labels = 0;
        do_atoms  = 1;
        do_bonds  = 0;

//        build_molecule (m, true);

//        glEndList();
        do_bonds  = orig_do_bonds;
        do_atoms  = orig_do_atoms;
        do_labels = orig_do_labels;
      }
  }

function get_context(canvas)
{
	try { gl=canvas.getContext("webkit-3d"); } catch(e) {}
	if(!gl) try { gl=canvas.getContext("moz-webgl"); } catch(e) {}
}

function initGL(canvas){
	var gl=get_context(canvas);
  if (!gl)
    return gl;

  gl.viewportWidth = canvas.width;
  gl.viewportHeight = canvas.height;
}

function initShaders(){
	var vertexShaderScript = document.getElementById("shader-vs");
	var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, vertexShaderScript.text);
	gl.compileShader(vertexShader);
	if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
		alert("Couldn't compile the vertex shader");
		gl.deleteShader(vertexShader);
		return;
	}

	var fragmentShaderScript = document.getElementById("shader-fs");
	var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, fragmentShaderScript.text);
	gl.compileShader(fragmentShader);
	if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
		alert("Couldn't compile the fragment shader");
		gl.deleteShader(fragmentShader);
		return;
	}


	gl.program = gl.createProgram();
	gl.attachShader(gl.program, vertexShader);
	gl.attachShader(gl.program, fragmentShader);
	gl.linkProgram(gl.program);

	if (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) {
		alert("Unable to initialise shaders");
		gl.deleteProgram(gl.program);
		gl.deleteProgram(vertexShader);
		gl.deleteProgram(fragmentShader);
		return;
	}

	gl.useProgram(gl.program);
  vertexPositionAttribute = gl.getAttribLocation(gl.program, "aVertexPosition");
	gl.enableVertexAttribArray(vertexPositionAttribute);
}

function initBuffers(){
  parse_pdb_data (molecule, molecules_pdb[0])
  var formula = generate_molecule_formula (molecule);
  generate_molecule_vertex_buffers(molecule);
}

function drawScene()
{
  gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
  loadIdentity();

  mvTranslate([-1.5, 0.0, -8.0])

  mvPushMatrix();
//  mvRotate(rPyramid, [0, 1, 0]);

  gl.bindBuffer(gl.ARRAY_BUFFER, vbuf.buffer);
  gl.vertexAttribPointer(vertexPositionAttribute, vbuf.itemSize, gl.FLOAT, false, 0, 0);
  setMatrixUniforms();
	gl.drawArrays(gl.TRIANGLES_STRIP, 0, vbuf.numItems);
}

function webGLStart()
{
  var canvas = document.getElementById("canvas");
  initGL(canvas);
  initShaders();
  initBuffers();

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clearDepth(1.0)
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);

  //setInterval(drawScene, 15);
  drawScene();

}




















function draw_molecule ()
{
  glPushMatrix ();
  glScalef(1.1, 1.1, 1.1);

//TODO:
/*
  {
    double x, y, z;
    get_position (mc->rot, &x, &y, &z, !mc->button_down_p);
    glTranslatef((x - 0.5) * 9,
                 (y - 0.5) * 9,
                 (z - 0.5) * 9);

    gltrackball_rotate (mc->trackball);

    get_rotation (mc->rot, &x, &y, &z, !mc->button_down_p);
    glRotatef (x * 360, 1.0, 0.0, 0.0);
    glRotatef (y * 360, 0.0, 1.0, 0.0);
    glRotatef (z * 360, 0.0, 0.0, 1.0);
  }
*/

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


/*
  glPushMatrix();
//TODO:
  glCallList (mc->molecule_dlist);


      draw_labels (mi);
*/
      /* This can't go in the display list, or the characters are spaced
         wrongly when the window is resized. */
/*
      if (do_titles && m->label && *m->label)
        {
          set_atom_color (mi, 0, True, 1);
          print_gl_string (mi->dpy, mc->xfont2, mc->font2_dlist,
                           mi->xgwa.width, mi->xgwa.height,
                           10, mi->xgwa.height - 10,
                           m->label, False);
        }
    }
  glPopMatrix();
*/

  if (do_shells)
    {
      gl.ColorMask (GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
      gl.PushMatrix();

      render_shell(m);
//      glCallList (m.shell_dlist);
      gl.PopMatrix();
      gl.ColorMask (GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);

      gl.DepthFunc (GL_EQUAL);
      gl.Enable (GL_BLEND);
      gl.BlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      gl.PushMatrix();
      render_shell(m);
//     glCallList (m.shell_dlist);
      gl.PopMatrix();
      gl.DepthFunc (GL_LESS);
      gl.Disable (GL_BLEND);
    }

  glPopMatrix ();

//  mi->polygon_count = mc->polygon_count;

//  if (mi->fps_p) do_fps (mi);
  glFinish();

  //glXSwapBuffers(dpy, window);
}

