Index: content/wikisubs.xml
===================================================================
--- content/wikisubs.xml	(revisão 63)
+++ content/wikisubs.xml	(cópia de trabalho)
@@ -37,11 +37,167 @@
 */
 -->
 
-  <binding id="wikisubs"
-               extends="chrome://global/content/bindings/videocontrols.xml#videoControls">
+  <binding id="subtitlesmenu">
+    <content>
+      <xul:button class="subtitlesButton" type="menu" position="before_end" dir="reverse" hidden="true">
+        <xul:menupopup class="subtitlesMenu" />
+      </xul:button>
+    </content>
+
+    <implementation>
+      <field name="subtitlesMenuUtils">
+          <![CDATA[ ({
+                init : function(binding){
+                    var self=this;
+
+                    //TODO: ugly! 
+                    this.video = binding.parentNode.parentNode.parentNode.parentNode.parentNode;
+                    this.communication_element = document.createElement("WikiSubsCommunicationElement");
+                    this.video.appendChild(this.communication_element);
+
+                    this.subtitlesMenu = document.getAnonymousElementByAttribute(binding, "class", "subtitlesMenu");
+                    this.subtitlesButton = document.getAnonymousElementByAttribute(binding, "class", "subtitlesButton");
+                    this.addMenuLink("Subtitles wiki page...", "http://www.wstr.org/subs/");
+
+                    for (i in this.video.childNodes){
+                      var node = this.video.childNodes[i];
+                      if (node.tagName == "ITEXT"){
+                          this.addSubtitle({"title": node.id,
+                            "lang": node.getAttribute("lang"),
+                             "url": node.getAttribute("src"),
+                              "itext_node": node });
+                          this.subtitlesButton.setAttribute("hidden", "false");
+                      }
+                    }
+
+                    this.video.addEventListener("DOMNodeInserted", function(event) { self.videoChildInserted(event); }, false);
+
+                    //TODO: Why?!
+                    //self.video.addEventListener("load", function(){ self.look_for_available_subtitles(); }, false);
+                    window.setInterval ( function(){ self.look_for_available_subtitles(); } );
+
+                },
+
+                addMenuCallback : function (title, callback){
+                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+                    var item = document.createElementNS(xulns, "menuitem");
+                    item.setAttribute("label", title);
+                    item.addEventListener("click", callback, false);
+                    this.subtitlesMenu.appendChild(item);
+                },
+
+                /* This will add an option in the subtitles menu that will open a new tab and let the
+                 user interact directly with the subtitles wiki repository */
+                addMenuLink : function (title, url){
+                  var self=this;
+                  this.addMenuCallback(title, function(e) {
+                    self.communication_element.setAttribute("url", url); 
+                    self.emit_event("WikiSubsOpenTab", self.communication_element);
+                  }, false);
+                },
+
+/*
+Silvia Pfeiffer is working on video accessibility on Mozilla. She is drafting a proposal to
+W3C and WHATWG to incorporate subtitling/closed captioning markup in the HTML5 spec.
+ Her work suggests that itext DOM nodes could be added as video element child nodes
+ in order to reference external subtitling/closed captining resources.
+
+ I decided to emulate the proposed behaviour in my addon so that it would be easier to refactor it
+in the future in case her proposal gets accepted and incorporated into the standard.
+*/
+                addSubtitle : function (sub){
+                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+                    var item = document.createElementNS(xulns, "menuitem");
+                    item.setAttribute("label", sub["title"]);
+
+                    var self = this;
+//                    sub["itext_node"].addEventListener("DOMNodeInserted", function(event) { self.itextChildInserted(event); }, false);
+                    item.addEventListener("click", function(e) {self.editor.fetch(sub, sub["itext_node"]);}, false);
+                    this.subtitlesMenu.appendChild(item);
+                    this.subtitlesButton.setAttribute("hidden", "false");
+                },
+
+                /*this will ask the wiki repository for a list of subtitles that match the current video:*/
+                look_for_available_subtitles : function(){
+                    this.emit_event("WikiSubsLoadSubList", this.communication_element);
+                },
+
+/*
+This addon uses XMLHttpRequest to fetch and save content to a subtitles (wiki) repository. 
+
+Gavin Sharp gave me this advice:
+
+Cross-site XMLHttpRequest *in chrome code* works in extensions, but since you're actually
+ extending a content-hosted video control, you're not able to take advantage of it (the security
+ policies of the video-hosting website are in effect).
+
+To work around the issue, you could have your binding generate a custom event when it wants
+ to retrieve data, and have a chrome-hosted listener watch for that event and take care of the
+ request. See https://developer.mozilla.org/en/Code_snippets/Interaction_between_privileged_and_non-privileged_pages
+ for an example.
+*/
+                emit_event : function (eventName, node){
+                  var evt = document.createEvent("Events");
+                  evt.initEvent(eventName, true, false);
+                  node.dispatchEvent(evt);
+                },
+
+                videoChildInserted : function(event) {
+                    //I am trying to implement behaviour proposed by Silvia Pfeiffer
+                    //You can test it on http://bighead.poli.usp.br/~juca/teste/teste.html
+
+                    //This could be soon updated to support this second version of her spec: 
+                    //http://blog.gingertech.net/2009/10/06/new-proposal-for-captions-and-other-timed-text-for-html5/
+
+                    if (event.target.tagName == "itext"){
+                        this.addSubtitle({"title": event.target.id,
+                          "lang": event.target.getAttribute("lang"),
+                           "url": event.target.getAttribute("src"),
+                            "itext_node": event.target });
+
+                        this.subtitlesButton.setAttribute("hidden", "false");
+                    }
+                }
+
+            }) ]]>
+        </field>
+
+  			<method name="set_editor">
+          <parameter name="subtitles_editor" />
+				  <body>
+	        <![CDATA[
+            this.subtitlesMenuUtils.editor = subtitles_editor;
+	        ]]>
+				  </body>
+        </method>
+
+        <constructor>
+            <![CDATA[
+                this.subtitlesMenuUtils.init(this);
+            ]]>
+        </constructor>
+    </implementation>
+
+  </binding>
+
+
+  <binding id="subtitleseditor">
+    <content>
+      <xul:hbox class="subtitle_editor_hbox" hidden="true">
+        <xul:vbox class="subtitle_interval_vbox" flex="1">
+          <xul:scale movetoclick="true" class="subtitle_interval_scale left_arrow" />
+          <xul:scale movetoclick="true" class="subtitle_interval_scale right_arrow" />
+        </xul:vbox>
+        <xul:button label="Save" class="plain wikisubs_button save_button" />
+        <xul:button label="Cancel" class="plain wikisubs_button cancel_button" />
+      </xul:hbox>
+      <xul:textbox class="plain subtitles_textbox" multiline="true" spellcheck="false" />
+    </content>
+
       <implementation>
-        <field name="wikisubsUtils">
+        <field name="editorUtils">
             <![CDATA[ ({
+                edit_mode : false,
                 video : null,
                 subtitlesMenu : null,
                 button : null,
@@ -102,72 +258,85 @@
                   return text;
                 },
 
-/*
-This addon uses XMLHttpRequest to fetch and save content to a subtitles (wiki) repository. 
+//This is a test. I plan to have an annotation overlay to be rendered
+// using SVG on top of the video.
+// You can see a demo of the balloon XBL at this page:
+// http://www.wstr.org/xbl_example/ann_example.xul
 
-Gavin Sharp gave me this advice:
+//TODO: check whether it is a good thing. Otherwise, remove it.
+                addBalloon : function(x,y,w,h,px,py, text){
+                    var balloon = document.createElement("annotation");
+                    balloon.setAttribute("id", "myballoon");
+                    this.annotations_overlay.appendChild(balloon);
 
-Cross-site XMLHttpRequest *in chrome code* works in extensions, but since you're actually
- extending a content-hosted video control, you're not able to take advantage of it (the security
- policies of the video-hosting website are in effect).
+                    //For some reason I had to explicitely add the binding to each new balloon:
+                    document.addBinding(balloon, "chrome://global/content/annotations.xml#annotation");
+ 
+                    update_balloon = function(evt){
 
-To work around the issue, you could have your binding generate a custom event when it wants
- to retrieve data, and have a chrome-hosted listener watch for that event and take care of the
- request. See https://developer.mozilla.org/en/Code_snippets/Interaction_between_privileged_and_non-privileged_pages
- for an example.
-*/
-                emit_event : function (eventName, node){
-                  var evt = document.createEvent("Events");
-                  evt.initEvent(eventName, true, false);
-                  node.dispatchEvent(evt);
-                },
+                    var x = evt.clientX;
+                    var y = evt.clientY;
 
-                fetch : function (sub, node){
-                  if (!node) node = this.communication_element;
-                  this.loading_subtitles = true;
-                  sub["content"] = [];
-                  this.current_subtitle = sub
-                  this.communication_element.setAttribute("src", sub["url"]); 
-                  this.emit_event("WikiSubsLoadSub", node);
+                      balloon.setDimensions(20,70,50,40);
+                      balloon.setPointer(x, y);
+                      balloon.setText("X:"+x +" Y:"+ y);
+                    }
+
+                  window.onmousemove = update_balloon;
                 },
 
-                addMenuCallback : function (title, callback){
-                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-                    var item = document.createElementNS(xulns, "menuitem");
-                    item.setAttribute("label", title);
-                    item.addEventListener("click", callback, false);
-                    this.subtitlesMenu.appendChild(item);
+                enter_edit_mode : function(event){
+alert("enter_edit_mode");
+                    this.edit_mode = true;
+                    this.original_text = this.subtitles_textbox.value;
+                    this.original_star = this.interval_start.value;
+                    this.original_end = this.interval_end.value;
+
+                    this.video.pause();
+                    this.subtitles_textbox.style.background = "rgba(255,255,128, 0.3)"
+                    this.editor_hbox.setAttribute("hidden", "false");
+                    this.set_subtitle_sliders_limits();
                 },
 
-                /* This will add an option in the subtitles menu that will open a new tab and let the
-                 user interact directly with the subtitles wiki repository */
-                addMenuLink : function (title, url){
-                  var self=this;
-                  this.addMenuCallback(title, function(e) {
-                    self.communication_element.setAttribute("url", url); 
-                    self.emit_event("WikiSubsOpenTab", self.communication_element);
-                  }, false);
+                exit_edit_mode : function(resume) {
+alert("exit edit mode");
+                    this.edit_mode=false;
+                    this.subtitles_textbox.style.background = "transparent"
+                    this.editor_hbox.setAttribute("hidden", "true");
+                    if (resume) this.video.play();
                 },
 
-/*
-Silvia Pfeiffer is working on video accessibility on Mozilla. She is drafting a proposal to
-W3C and WHATWG to incorporate subtitling/closed captioning markup in the HTML5 spec.
- Her work suggests that itext DOM nodes could be added as video element child nodes
- in order to reference external subtitling/closed captining resources.
+                saveSubs : function(){
+                  //ignore save if current sub is not altered
+                  //(we save immediatly after user edits so only the current sub mathers)
+                  if (this.subtitles_textbox.value == this.original_text &&
+                      this.interval_start.value == this.original_start &&
+                      this.interval_end.value == this.original_end) return;
 
- I decided to emulate the proposed behaviour in my addon so that it would be easier to refactor it
-in the future in case her proposal gets accepted and incorporated into the standard.
-*/
-                addSubtitle : function (sub){
-                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-                    var item = document.createElementNS(xulns, "menuitem");
-                    item.setAttribute("label", sub["title"]);
+                  if (this.current_subtitle_index == -1){
+                    this.current_subtitle["content"].push(
+                        {"text": this.subtitles_textbox.value,
+                         "start": this.interval_start.value,
+                         "end": this.interval_end.value});
+                  } else {
+                    this.current_subtitle["content"][this.current_subtitle_index]["text"] = this.subtitles_textbox.value;
+                    this.current_subtitle["content"][this.current_subtitle_index]["start"] = this.interval_start.value;
+                    this.current_subtitle["content"][this.current_subtitle_index]["end"] = this.interval_end.value;
+                  }
 
-                    var self = this;
-                    sub["itext_node"].addEventListener("DOMNodeInserted", function(event) { self.itextChildInserted(event); }, false);
-                    item.addEventListener("click", function(e) {self.fetch(sub, sub["itext_node"]);}, false);
-                    this.subtitlesMenu.appendChild(item);
-                    this.subtitlesButton.setAttribute("hidden", "false");
+                  //remove this subtitle chunk if user has deleted all text in the textbox
+                  if (this.subtitles_textbox.value==""){
+                    this.current_subtitle["content"].splice(this.current_subtitle_index, 1);
+                  }
+
+                  //This may seem complicated, but I am doing it in order to
+                  // keep itext attributes compliant to Silvia's spec: 
+                  var pagename = this.current_subtitle["url"].split("title=")[1];
+
+                  var srt = this.encode_SRT(this.current_subtitle["content"]);
+                  this.communication_element.setAttribute("pagename", pagename);
+                  this.communication_element.setAttribute("srt", srt);
+                  this.emit_event("WikiSubsSaveSub", this.communication_element);
                 },
 
 /*
@@ -226,117 +395,86 @@
                   this.interval_end.setAttribute("max", now + 3000);
                 },
 
-                /*this will ask the wiki repository for a list of subtitles that match the current video:*/
-                look_for_available_subtitles : function(){
-                    this.emit_event("WikiSubsLoadSubList", this.communication_element);  
+//TODO: duplicated method. MUST refactor!
+                emit_event : function (eventName, node){
+                  var evt = document.createEvent("Events");
+                  evt.initEvent(eventName, true, false);
+                  node.dispatchEvent(evt);
                 },
 
-//This is a test. I plan to have an annotation overlay to be rendered
-// using SVG on top of the video.
-// You can see a demo of the balloon XBL at this page:
-// http://www.wstr.org/xbl_example/ann_example.xul
+              init : function(binding){
+                    self = this;
+                    //TODO: make it cleaner:
+                    this.video = binding.parentNode.parentNode.parentNode.parentNode;
+alert(this.video);
+//TODO: there are 2 WikiSubsCommunicationElement elements!
+                    this.communication_element = document.createElement("WikiSubsCommunicationElement");
+                    this.video.appendChild(this.communication_element);
 
-//TODO: check whether it is a good thing. Otherwise, remove it.
-                addBalloon : function(x,y,w,h,px,py, text){
-                    var balloon = document.createElement("annotation");
-                    balloon.setAttribute("id", "myballoon");
-                    this.annotations_overlay.appendChild(balloon);
+                    this.video.addEventListener("timeupdate", function() { self.displaySubtitles(); }, false);
 
-                    //For some reason I had to explicitely add the binding to each new balloon:
-                    document.addBinding(balloon, "chrome://global/content/annotations.xml#annotation");
- 
-                    update_balloon = function(evt){
+                    var save_button = document.getAnonymousElementByAttribute(binding, "class", "plain wikisubs_button save_button");
+                    var cancel_button = document.getAnonymousElementByAttribute(binding, "class", "plain wikisubs_button cancel_button");
+                    this.subtitles_textbox = document.getAnonymousElementByAttribute(binding, "class", "plain subtitles_textbox");
+                    this.subtitlesMenu = document.getAnonymousElementByAttribute(binding, "class", "subtitlesMenu");
+                    this.interval_start = document.getAnonymousElementByAttribute(binding, "class", "left_arrow");
+                    this.interval_end = document.getAnonymousElementByAttribute(binding, "class", "right_arrow");
+                    this.editor_hbox = document.getAnonymousElementByAttribute(binding, "class", "subtitle_editor_hbox");
 
-                    var x = evt.clientX;
-                    var y = evt.clientY;
+                    save_button.addEventListener("click", function(){ self.saveSubs(); self.exit_edit_mode(true); } , false);
+                    cancel_button.addEventListener("click", function(){ self.exit_edit_mode(true) } , false);
+                    this.subtitles_textbox.addEventListener("click", function(event){ self.enter_edit_mode(); }, false);
+                    this.exit_edit_mode(false);                
+              }
 
-                      balloon.setDimensions(20,70,50,40);
-                      balloon.setPointer(x, y);
-                      balloon.setText("X:"+x +" Y:"+ y);
-                    }
+            }) ]]>
+        </field>
 
-                  window.onmousemove = update_balloon;
-                },
+        <method name="fetch">
+          <parameter name="sub" />
+          <parameter name="node" />
+            <body>
+                  if (!node) node = this.communication_element;
+                  this.loading_subtitles = true;
+                  sub["content"] = [];
+                  this.current_subtitle = sub
+                  this.editorUtils.communication_element.setAttribute("src", sub["url"]); 
+                  this.editorUtils.emit_event("WikiSubsLoadSub", node);
+            </body>
+        </method>
 
+        <constructor>
+            <![CDATA[
+                this.editorUtils.init(this);
+            ]]>
+        </constructor>
+    </implementation>
+  </binding>
+
+  <binding id="wikisubs"
+               extends="chrome://global/content/bindings/videocontrols.xml#videoControls">
+      <implementation>
+        <field name="wikisubsUtils">
+            <![CDATA[ ({
+
                 init : function (binding) {
                     dump("\n--------- wikisubs constructor ---------\n\n");
                     var self = this;
+                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
                     this.video = binding.parentNode;
 
-                    this.communication_element = document.createElement("WikiSubsCommunicationElement");
-                    this.video.appendChild(this.communication_element);
-
-                    // XBL doesn't have a good way to inject content into the middle of
-                    // something else, so we'll insert our content via DOM manipulation.
-                    //This same user interface is declared statically in the patch I have
-                    // attached to bug #515898 at bugzilla 
-                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
-                    this.subtitlesButton = document.createElementNS(xulns, "button");
-                    this.subtitlesButton.setAttribute("class", "subtitlesButton");
-                    this.subtitlesButton.setAttribute("type", "menu");
-
-                    this.subtitlesMenu = document.createElementNS(xulns, "menupopup");
-                    this.subtitlesButton.appendChild(this.subtitlesMenu);
-                    this.subtitlesButton.setAttribute("type", "menu");
-                    this.subtitlesButton.setAttribute("position", "before_end");
-                    this.subtitlesButton.setAttribute("dir", "reverse");
-
-                    this.subtitles_textbox = document.createElementNS(xulns, "textbox");
-                    this.editor_hbox = document.createElementNS(xulns, "hbox");
-                    this.save_button = document.createElementNS(xulns, "button");
-                    this.save_button.setAttribute("label", "Save");
-                    this.save_button.setAttribute("class", "plain wikisubs_button");
-                    this.save_button.addEventListener("click", function(){ self.saveSubs(); self.exit_edit_mode(true); } , false);
-
-                    this.cancel_button = document.createElementNS(xulns, "button");
-                    this.cancel_button.setAttribute("label", "Cancel");
-                    this.cancel_button.setAttribute("class", "plain wikisubs_button");
-                    this.cancel_button.addEventListener("click", function(){ self.exit_edit_mode(true) } , false);
-
-                    var interval_vbox = document.createElementNS(xulns, "vbox");
-                    interval_vbox.setAttribute("flex", "1");
-                    interval_vbox.setAttribute("class", "subtitle_interval_hbox");
-                    this.interval_start = document.createElementNS(xulns, "scale");
-                    this.interval_start.setAttribute("movetoclick", "true");
-                    this.interval_start.setAttribute("class", "subtitle_interval_scale left_arrow");
-                    this.interval_end = document.createElementNS(xulns, "scale");
-                    this.interval_end.setAttribute("movetoclick", "true");
-                    this.interval_end.setAttribute("class", "subtitle_interval_scale right_arrow");
-                    interval_vbox.appendChild(this.interval_start);
-                    interval_vbox.appendChild(this.interval_end);
-
-
-//                    this.editor_hbox.appendChild(this.interval_start);
-//                    this.editor_hbox.appendChild(this.interval_end);
-                    this.editor_hbox.appendChild(interval_vbox);
-                    this.editor_hbox.appendChild(this.save_button);
-                    this.editor_hbox.appendChild(this.cancel_button);
-                    this.exit_edit_mode(false);
-
-                    this.subtitles_textbox.addEventListener("click", function(event){ self.enter_edit_mode(); }, false);
-                    this.subtitles_textbox.setAttribute("class", "plain subtitles_textbox");
-                    this.subtitles_textbox.setAttribute("multiline", "true");
-
-//MDC states:    spellcheck   New in Firefox 2.0.0.2
-//                      Type: boolean 
-//                      "If true, spell checking is enabled by default for the text box; if false, spell checking is disabled by default."
-//                      "If not specified, this defaults to false "
-//                      (but it seems to be true by default...)
-//                    this.subtitles_textbox.spellcheck=false;
-//                    this.subtitles_textbox.spellcheck=false;
-
                     //Subtitles will be displayed above the controls:
+                    var subtitles_editor = document.createElementNS(xulns, "subtitleseditor");
                     var controlBar = document.getAnonymousElementByAttribute(binding, "class", "controlBar");
-                    controlBar.parentNode.insertBefore(this.editor_hbox, controlBar);
-                    controlBar.parentNode.insertBefore(this.subtitles_textbox, controlBar);
+                    controlBar.parentNode.insertBefore(subtitles_editor, controlBar);
+                    subtitles_editor.setAttribute("style", '-moz-binding:url("chrome://global/content/wikisubs.xml#subtitleseditor");');
 
                     //Subtitles menu will be near the mute button:
+                    this.subtitlesmenu =  document.createElementNS(xulns, "subtitlesmenu");
+                    this.subtitlesmenu.setAttribute("style", '-moz-binding:url("chrome://global/content/wikisubs.xml#subtitlesmenu");');
                     var muteButton = document.getAnonymousElementByAttribute(binding, "class", "muteButton");
-                    muteButton.parentNode.insertBefore(this.subtitlesButton, muteButton);
-
-                    //Let it be initially hidden while we dont have a list of available subs:
-                    this.subtitlesButton.setAttribute("hidden", "true");
-
+                    muteButton.parentNode.insertBefore(this.subtitlesmenu, muteButton);
+                    this.subtitlesmenu.set_editor(subtitles_editor);
 /* Temporarily disabled. Experimental feature.
             //setup annotations overlay:
                     statusOverlay = document.getAnonymousElementByAttribute(binding, "class", "statusOverlay");
@@ -346,16 +484,7 @@
 
                     this.addBalloon(0,0,10,10,20,30,"testing");
 */
-                    self.video.addEventListener("DOMNodeInserted", function(event) { self.videoChildInserted(event); }, false);
-                    self.video.addEventListener("timeupdate", function() { self.displaySubtitles(); }, false);
 
-                    self.addMenuLink("Subtitles wiki page...", "http://www.wstr.org/subs/");
-
-                    //TODO: Why?!
-                    //self.video.addEventListener("load", function(){ self.look_for_available_subtitles(); }, false);
-                    window.setInterval ( function(){ self.look_for_available_subtitles(); } );
-
-
                     //This is a hack. we need a way to inhibit video controls handling of keypress
                     // events when we are typing text in the subtitles textbox, so that for instance
                     // typing a spacebar won't trigger togglePause
@@ -371,80 +500,12 @@
                     dump("--- wikisubs initialized ---\n");
                 },
 
+//todo> review this method. it seems wrong
                 itextChildInserted : function(event) {
                         this.current_subtitle["content"] = this.parse_SRT(event.target.data);
                         this.loading_subtitles = false;
                 },
 
-                videoChildInserted : function(event) {
-                    //I am trying to implement behaviour proposed by Silvia Pfeiffer
-                    //You can test it on http://bighead.poli.usp.br/~juca/teste/teste.html
-
-                    //This could be soon updated to support this second version of her spec: 
-                    //http://blog.gingertech.net/2009/10/06/new-proposal-for-captions-and-other-timed-text-for-html5/
-
-                    if (event.target.tagName == "itext"){
-                        this.addSubtitle({"title": event.target.id,
-                          "lang": event.target.getAttribute("lang"),
-                           "url": event.target.getAttribute("src"),
-                            "itext_node": event.target });
-
-                        this.subtitlesButton.setAttribute("hidden", "false");
-                    }
-                },
-
-                enter_edit_mode : function(event){
-                    this.edit_mode = true;
-                    this.original_text = this.subtitles_textbox.value;
-                    this.original_star = this.interval_start.value;
-                    this.original_end = this.interval_end.value;
-
-                    this.video.pause();
-                    this.subtitles_textbox.style.background = "rgba(255,255,128, 0.3)"
-                    this.editor_hbox.setAttribute("hidden", "false");
-                    this.set_subtitle_sliders_limits();
-                },
-
-                exit_edit_mode : function(resume) {
-                    this.edit_mode=false;
-                    this.subtitles_textbox.style.background = "transparent"
-                    this.editor_hbox.setAttribute("hidden", "true");
-                    if (resume) this.video.play();
-                },
-
-                saveSubs : function(){
-                  //ignore save if current sub is not altered
-                  //(we save immediatly after user edits so only the current sub mathers)
-                  if (this.subtitles_textbox.value == this.original_text &&
-                      this.interval_start.value == this.original_start &&
-                      this.interval_end.value == this.original_end) return;
-
-                  if (this.current_subtitle_index == -1){
-                    this.current_subtitle["content"].push(
-                        {"text": this.subtitles_textbox.value,
-                         "start": this.interval_start.value,
-                         "end": this.interval_end.value});
-                  } else {
-                    this.current_subtitle["content"][this.current_subtitle_index]["text"] = this.subtitles_textbox.value;
-                    this.current_subtitle["content"][this.current_subtitle_index]["start"] = this.interval_start.value;
-                    this.current_subtitle["content"][this.current_subtitle_index]["end"] = this.interval_end.value;
-                  }
-
-                  //remove this subtitle chunk if user has deleted all text in the textbox
-                  if (this.subtitles_textbox.value==""){
-                    this.current_subtitle["content"].splice(this.current_subtitle_index, 1);
-                  }
-
-                  //This may seem complicated, but I am doing it in order to
-                  // keep itext attributes compliant to Silvia's spec: 
-                  var pagename = this.current_subtitle["url"].split("title=")[1];
-
-                  var srt = this.encode_SRT(this.current_subtitle["content"]);
-                  this.communication_element.setAttribute("pagename", pagename);
-                  this.communication_element.setAttribute("srt", srt);
-                  this.emit_event("WikiSubsSaveSub", this.communication_element);
-                }
-
             }) ]]>
         </field>
 
Index: content/wikisubs.js
===================================================================
--- content/wikisubs.js	(revisão 63)
+++ content/wikisubs.js	(cópia de trabalho)
@@ -82,25 +82,29 @@
       var parse_sub_list = function(data){
         var lines = data.split("\n");
         for (i in lines){
-          //TODO try: catch:
-          var string = lines[i].split("[[")[1];
-          string = string.split("]]")[0];
-          string = string.split("|");
-          var pagename = string[0].trim();
-          var title = string[1].trim();
+          try{
+            var string = lines[i].split("[[")[1];
+            string = string.split("]]")[0];
+            string = string.split("|");
+            var pagename = string[0].trim();
+            var title = string[1].trim();
 
-          itext_node = document.createElement("itext");
-          itext_node.setAttribute("src", "http://www.wstr.org/subs/" + "index.php?action=raw&title=" + pagename);
-          itext_node.setAttribute("id", title);
-          //itext_node.setAttribute("cat", "");
-//          itext_node.setAttribute("lang", lang);
-          video.appendChild(itext_node);
+            itext_node = document.createElement("itext");
+            itext_node.setAttribute("src", "http://www.wstr.org/subs/" + "index.php?action=raw&title=" + pagename);
+            itext_node.setAttribute("id", title);
+            //itext_node.setAttribute("cat", "");
+  //          itext_node.setAttribute("lang", lang);
+            video.appendChild(itext_node);
+          } catch(e) {
+            //do nothing.
+          }
         }
       }
 
       var src = video.currentSrc;
       if (!src) src = video.getElementsByTagName("source")[0].src;
 
+      //TODO: treat file:// differently
       this.loadMediawikiPage("http://www.wstr.org/subs/", "Subtitles/URL/" + src, parse_sub_list);
     },

