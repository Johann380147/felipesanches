<?xml version="1.0"?>

<bindings id="wikisubsBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl"
	 xmlns:svg="http://www.w3.org/2000/svg" 
   xmlns:html="http://www.w3.org/1999/xhtml" 
>

<!--
/*
          This XML binding extends the video controls for html5 video and
           creates a collaborative subtitle user interface. The primary wiki repository is
           http://www.wstr.org/subs/

          While implementing this, I have noticed that part of the functionality could be incorporated
           into a future version of Firefox while other things should remain as optional features
           to be installed in an addon.

          For instance, while the wiki features fit better in an addon, Firefox actually needs a 
           user interface for subtitles selection and display because some ogg videos might have
           subtitles embedded in it:
           
           https://bugzilla.mozilla.org/show_bug.cgi?id=481529 
           Bug 481529 -  Support for Kate overlay streams in <video> tag  

           During the development of this addon I have refactored portions of it and I have provided
           some patches to Firefox. User ogg.k.ogg.k@googlemail.com has merged my patch
           with his own and we've got a prototype ui for managing subtitles embedded in ogg.

           Here is the bug where the refactored version of this addon has been first published
           as a patch:

           https://bugzilla.mozilla.org/show_bug.cgi?id=515898
           Bug 515898 -  implement UI for subtitles on html5 video/audio
*/
-->

  <binding id="wikisubs"
               extends="chrome://global/content/bindings/videocontrols.xml#videoControls">
      <implementation>
        <field name="wikisubsUtils">
            <![CDATA[ ({
                video : null,
                subtitlesMenu : null,
                button : null,
                current_subtitle : null,
                loading_subtitles : false,
                edit_mode : false,

                /* SRT (subtitles file format) parsing and encoding routines: */

                toMilliSeconds: function (s){
                  var timeparts = s.split(',');
                  msecs = Number(timeparts[1]);
                  var timeparts = timeparts[0].split(':');
                  var hours = Number(timeparts[0]);
                  var mins = Number(timeparts[1]);
                  var secs = Number(timeparts[2]);

                  return (((hours*60 + mins) * 60) + secs)*1000 + msecs;
                },

                MilliSecondsToString: function(time){
                  var timeString;
                  var hours = Math.floor(time / 3600000);
                  var mins  = Math.floor(time % 3600000 / 60000);
                  var secs  = Math.floor(time % 60000 / 1000);
                  var msecs = time%1000;
                  if (secs < 10) secs = "0" + secs;
                  if (mins < 10) mins = "0" + mins;
                  if (hours < 10) hours = "0" + hours;
                  if (msecs < 10) msecs = "0" + msecs;
                  if (msecs < 100) msecs = "0" + msecs;
                  return hours + ":" + mins + ":" + secs + "," + msecs;
                },

                parse_SRT : function (text){
                  var blocks = text.split("\n\n");
                  var content = [];
                  for (var i=0; i<blocks.length; i++){
                    var block = blocks[i].split("\n");
                    //block[0] is the index. I'll ignore it. Could be used to check validity of the SRT
                    var timeinterval = block[1].split(' --> ');
                    var start = this.toMilliSeconds(timeinterval[0]);
                    var end = this.toMilliSeconds(timeinterval[1]);
                    content.push({'start':start, 'end':end, 'text':block[2]});
                  }
                  return content;
                },

                encode_SRT : function (sub){
                  text = ""
                  for (i in sub){
                      text+=(Number(i)+1)+"\n"
                      text+=this.MilliSecondsToString(sub[i]["start"])
                      text+=" --> "
                      text+=this.MilliSecondsToString(sub[i]["end"])+"\n";
                      text+=sub[i]["text"]+"\n\n";
                  }
                  return text;
                },

/*
This addon uses XMLHttpRequest to fetch and save content to a subtitles (wiki) repository. 

Gavin Sharp gave me this advice:

Cross-site XMLHttpRequest *in chrome code* works in extensions, but since you're actually
 extending a content-hosted video control, you're not able to take advantage of it (the security
 policies of the video-hosting website are in effect).

To work around the issue, you could have your binding generate a custom event when it wants
 to retrieve data, and have a chrome-hosted listener watch for that event and take care of the
 request. See https://developer.mozilla.org/en/Code_snippets/Interaction_between_privileged_and_non-privileged_pages
 for an example.
*/
                emit_event : function (eventName, node){
                  var evt = document.createEvent("Events");
                  evt.initEvent(eventName, true, false);
                  node.dispatchEvent(evt);
                },

                fetch : function (sub, node){
                  if (!node) node = this.communication_element;
                  this.loading_subtitles = true;
                  sub["content"] = [];
                  this.current_subtitle = sub
                  this.communication_element.setAttribute("src", sub["url"]); 
                  this.emit_event("WikiSubsLoadSub", node);
                },

                /* This will add an option in the subtitles menu that will open a new tab and let the
                 user interact directly with the subtitles wiki repository */
                addMenuLink : function (title, url){
                    var self=this;
                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
                    var item = document.createElementNS(xulns, "menuitem");
                    item.setAttribute("label", title);
                    item.addEventListener("click", function(e) {
                        self.communication_element.setAttribute("url", url); 
                        self.emit_event("WikiSubsOpenTab", self.communication_element);
                    }, false);
                    this.subtitlesMenu.appendChild(item);
                },

/*
Silvia Pfeiffer is working on video accessibility on Mozilla. She is drafting a proposal to
W3C and WHATWG to incorporate subtitling/closed captioning markup in the HTML5 spec.
 Her work suggests that itext DOM nodes could be added as video element child nodes
 in order to reference external subtitling/closed captining resources.

 I decided to emulate the proposed behaviour in my addon so that it would be easier to refactor it
in the future in case her proposal gets accepted and incorporated into the standard.
*/
                addSubtitle : function (sub){
                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
                    var item = document.createElementNS(xulns, "menuitem");
                    item.setAttribute("label", sub["title"]);

                    var self = this;
                    sub["itext_node"].addEventListener("DOMNodeInserted", function(event) { self.itextChildInserted(event); }, false);
                    item.addEventListener("click", function(e) {self.fetch(sub, sub["itext_node"]);}, false);
                    this.subtitlesMenu.appendChild(item);
                    this.subtitlesButton.setAttribute("hidden", "false");
                },

/*
Justin Dolske gave me this advice (but I havent implemented it yet):

This is terribly inefficient. The timeupdate event is dispatched every frame,
so running code in each event should be avoided as much as possible. Your
displaySubtitles() is also very inefficient, as it does a linear search though
the subtitles each time (!) it's called.

I'd suggest doing something like caching the min/max time for the current
subtitle, and bailing out early if .currentTime is between those two values
(because you then know the current subtitle doesn't need changed).
*/
                displaySubtitles : function(){
                  var currentTime = Math.round(this.video.currentTime * 1000); // in ms
                  if (this.loading_subtitles == true) {
                  //TODO: l10n
                    this.subtitles_textbox.value = "Loading subtitles...";
                    return;
                  }

                  if (this.current_subtitle == null) return;

                  var text = "";
                  var subs = this.current_subtitle["content"];
                  for (i=0; i < subs.length; i++){
                    if ((currentTime >= subs[i].start) && (currentTime < subs[i].end)){
                      text = subs[i]["text"];
                      this.current_subtitle_index = i;
                      break;
                    }
                  }
                  this.subtitles_textbox.value = text;
                },

                /*this will ask the wiki repository for a list of subtitles that match the current video:*/
                look_for_available_subtitles : function(){
                    this.emit_event("WikiSubsLoadSubList", this.communication_element);  
                },

//This is a test. I plan to have an annotation overlay to be rendered
// using SVG on top of the video.
// You can see a demo of the balloon XBL at this page:
// http://www.wstr.org/xbl_example/ann_example.xul

//TODO: check whether it is a good thing. Otherwise, remove it.
                addBalloon : function(x,y,w,h,px,py, text){
                    var balloon = document.createElement("annotation");
                    balloon.setAttribute("id", "myballoon");
                    this.annotations_overlay.appendChild(balloon);

                    //For some reason I had to explicitely add the binding to each new balloon:
                    document.addBinding(balloon, "chrome://global/content/annotations.xml#annotation");
 
                    update_balloon = function(evt){

                    var x = evt.clientX;
                    var y = evt.clientY;

                      balloon.setDimensions(20,70,50,40);
                      balloon.setPointer(x, y);
                      balloon.setText("X:"+x +" Y:"+ y);
                    }

                  window.onmousemove = update_balloon;
                },

                init : function (binding) {
                    dump("\n--------- wikisubs constructor ---------\n\n");
                    var self = this;
                    this.video = binding.parentNode;

                    this.communication_element = document.createElement("WikiSubsCommunicationElement");
                    this.video.appendChild(this.communication_element);

                    // XBL doesn't have a good way to inject content into the middle of
                    // something else, so we'll insert our content via DOM manipulation.
                    //This same user interface is declared statically in the patch I have
                    // attached to bug #515898 at bugzilla 
                    var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
                    this.subtitlesButton = document.createElementNS(xulns, "button");
                    this.subtitlesButton.setAttribute("class", "subtitlesButton");
                    this.subtitlesButton.setAttribute("type", "menu");

                    this.subtitlesMenu = document.createElementNS(xulns, "menupopup");
                    this.subtitlesButton.appendChild(this.subtitlesMenu);
                    this.subtitlesButton.setAttribute("type", "menu");
                    this.subtitlesButton.setAttribute("position", "before_end");
                    this.subtitlesButton.setAttribute("dir", "reverse");

                    this.subtitles_textbox = document.createElementNS(xulns, "textbox");
                    this.editor_hbox = document.createElementNS(xulns, "hbox");
                    this.save_button = document.createElementNS(xulns, "button");
                    this.save_button.setAttribute("label", "Save");
                    this.save_button.setAttribute("class", "plain wikisubs_button");
                    this.save_button.addEventListener("click", function(){ self.saveSubs(); self.exit_edit_mode(); } , false);

                    this.cancel_button = document.createElementNS(xulns, "button");
                    this.cancel_button.setAttribute("label", "Cancel");
                    this.cancel_button.setAttribute("class", "plain wikisubs_button");
                    this.cancel_button.addEventListener("click", function(){ self.exit_edit_mode() } , false);

                    this.editor_hbox.appendChild(this.save_button);
                    this.editor_hbox.appendChild(this.cancel_button);
                    this.exit_edit_mode();

                    this.subtitles_textbox.addEventListener("click", function(event){ self.enter_edit_mode(); }, false);
                    this.subtitles_textbox.setAttribute("class", "plain subtitles_textbox");
                    this.subtitles_textbox.setAttribute("multiline", "true");

//MDC states:    spellcheck   New in Firefox 2.0.0.2
//                      Type: boolean 
//                      "If true, spell checking is enabled by default for the text box; if false, spell checking is disabled by default."
//                      "If not specified, this defaults to false "
//                      (but it seems to be true by default...)
//                    this.subtitles_textbox.spellcheck=false;
//                    this.subtitles_textbox.spellcheck=false;

                    //Subtitles will be displayed above the controls:
                    var controlBar = document.getAnonymousElementByAttribute(binding, "class", "controlBar");
                    controlBar.parentNode.insertBefore(this.editor_hbox, controlBar);
                    controlBar.parentNode.insertBefore(this.subtitles_textbox, controlBar);

                    //Subtitles menu will be near the mute button:
                    var muteButton = document.getAnonymousElementByAttribute(binding, "class", "muteButton");
                    muteButton.parentNode.insertBefore(this.subtitlesButton, muteButton);

                    //Let it be initially hidden while we dont have a list of available subs:
                    this.subtitlesButton.setAttribute("hidden", "true");

/* Temporarily disabled. Experimental feature.
            //setup annotations overlay:
                    statusOverlay = document.getAnonymousElementByAttribute(binding, "class", "statusOverlay");
                    this.annotations_overlay = document.createElementNS(xulns, "stack");
                    this.annotations_overlay.setAttribute("flex", "1");
                    statusOverlay.parentNode.insertBefore(this.annotations_overlay, statusOverlay);

                    this.addBalloon(0,0,10,10,20,30,"testing");
*/
                    self.video.addEventListener("DOMNodeInserted", function(event) { self.videoChildInserted(event); }, false);
                    self.video.addEventListener("timeupdate", function() { self.displaySubtitles(); }, false);

                    self.addMenuLink("Subtitles wiki page...", "http://www.wstr.org/subs/");

                    //TODO: Why?!
                    //self.video.addEventListener("load", function(){ self.look_for_available_subtitles(); }, false);
                    window.setInterval ( function(){ self.look_for_available_subtitles(); } );


                    //This is a hack. we need a way to inhibit video controls handling of keypress
                    // events when we are typing text in the subtitles textbox, so that for instance
                    // typing a spacebar won't trigger togglePause
                    binding.Utils.original_keyHandler = binding.Utils.keyHandler;
                    binding.Utils.keyHandler = function(event){
                      if (self.edit_mode==false)
                        binding.Utils.original_keyHandler(event);
                    };

                    var playButton = document.getAnonymousElementByAttribute(binding, "class", "playButton");
                    playButton.addEventListener("click", function(){ if (self.edit_mode) self.exit_edit_mode(); }, false);

                    dump("--- wikisubs initialized ---\n");
                },

                itextChildInserted : function(event) {
                        this.current_subtitle["content"] = this.parse_SRT(event.target.data);
                        this.loading_subtitles = false;
                },

                videoChildInserted : function(event) {
                    //I am trying to implement behaviour proposed by Silvia Pfeiffer
                    //You can test it on http://bighead.poli.usp.br/~juca/teste/teste.html

                    if (event.target.tagName == "itext"){
                        this.addSubtitle({"title": event.target.id,
                          "lang": event.target.getAttribute("lang"),
                           "url": event.target.getAttribute("src"),
                            "itext_node": event.target });

                        this.subtitlesButton.setAttribute("hidden", "false");
                    }
                },

                enter_edit_mode : function(event){
                    this.edit_mode = true;
                    this.original_text = this.subtitles_textbox.value;
                    this.video.pause();
                    this.subtitles_textbox.style.background = "rgba(255,255,128, 0.3)"
                    this.editor_hbox.setAttribute("hidden", "false");
                },

                exit_edit_mode : function() {
                    this.edit_mode=false;
                    this.subtitles_textbox.style.background = "transparent"
                    this.editor_hbox.setAttribute("hidden", "true");
                    this.video.play();
                },

                saveSubs : function(){
                  if (this.subtitles_textbox.value == this.original_text) return;
                  this.current_subtitle["content"][this.current_subtitle_index]["text"] = this.subtitles_textbox.value;

                  //This may seem complicated, but I am doing it in order to
                  // keep itext attributes compliant to Silvia's spec: 
                  var pagename = this.current_subtitle["url"].split("title=")[1];

                  var srt = this.encode_SRT(this.current_subtitle["content"]);
                  this.communication_element.setAttribute("pagename", pagename);
                  this.communication_element.setAttribute("srt", srt);
                  this.emit_event("WikiSubsSaveSub", this.communication_element);
                }

            }) ]]>
        </field>

        <constructor>
            <![CDATA[
                this.wikisubsUtils.init(this);
            ]]>
        </constructor>
      </implementation>

      <resources>
        <stylesheet src="chrome://wikisubs/skin/wikisubs.css"/>
      </resources>
  </binding>

</bindings>

